"use strict";

/**
 * This script exports some sample JSON data that conforms to the `VIZ-SCHEMA.js` specification. This data is
 * primarily used to mock real data generated by the API that is used to populate the variable list and viewers.
 */

/** This string prefix marks special strings that are interpreted as symbol IDs. */
const REF = "@id:";

// =====================================================================================================================
// Mock VisualDebugger python program.
// =====================================================================================================================

// Python primitives
// -----------------
// - The "data" field is ignored for primitives that are not numbers.
// - There will never be unnamed primitive schemas, because primitive data is inlined.

const namedInt = {
    "type": "number",
    "str": "86",
    "name": "myInt",
    "data": 86,
};

const namedFloat = {
    "type": "number",
    "str": "3.14159",
    "name": "myFloat",
    "data": 3.14159,
};

const namedBool = {
    "type": "bool",
    "str": "True",
    "name": "myBool",
    "data": true,
};

const namedString = {
    "type": "string",
    "str": "The quick brown fox jumps over the lazy dog.",
    "name": "myString",
};

const namedNone = {
    "type": "none",
    "str": "None",
    "name": "myNone",
};


// Python containers
// -----------------
// - These objects are lazy-loaded, so their shells and their data are sent separately.

const namedListShell = {
    "type": "list",
    "str": "List[6]",
    "name": "myList",
    "data": null,
};
const namedListData = {
    "viewer": {
        "contents": [1, 2.3, false, "hello", null, `${REF}106`],
        "length": 6,  // TODO: Is this necessary?
    },
    "attributes": {}
};
const namedListRefs = [`${REF}106`];

const anonListShell = {
    "type": "list",
    "str": "List[3]",
    "data": null,
}
const anonListData = {
    "viewer": {
        "contents": [10, 11, `${REF}206`],
        "length": 3,  // TODO: Is this necessary?
    },
    "attributes": {}
}
const anonListRefs = [`${REF}206`];

const anonListShell2 = {
    "type": "list",
    "str": "List[4]",
    "data": null,
}
const anonListData2 = {
    "viewer": {
        "contents": ["This", "is", "the", "end."],
        "length": 4,  // TODO: Is this necessary?
    },
    "attributes": {}
}
const anonListRefs2 = [];

// TODO: Fill in schema/data for other objects. Can make data terminal because nesting already tested for list example.
// const namedSetShell = {};
// const namedSetData = {};
//
// const namedDictShell = {};
// const namedDictData = {};
//
// const namedClassShell = {};
// const namedClassData = {};
//
// const namedModuleShell = {};
// const namedModuleData = {};
//
// const namedFunctionShell = {};
// const namedFunctionData = {};
//
// const namedObjectShell = {};
// const namedObjectData = {};


// Xnode graph objects
// -------------------
// - The computational graph is defined through links maintained within GraphOpNode and GraphData objects.

const namedGraphDataShell = {
    "type": "graphdata",
    "str": "GraphData",
    "name": "Named GraphData",
    "data": null,
};
const namedGraphDataData = {
    "viewer": {
        "creatorop": `${REF}107`,
    },
    "attributes": {}
};
const namedGraphDataRefs = [`${REF}107`];

const anonGraphOpShell = {
    "type": "graphop",
    "str": "GraphOpNode",
    "name": null,
    "data": null,
};
const anonGraphOpData = {
    "viewer": {
        "args": [null, `${REF}207`],
        "kwargs": {
            "kwarg1": `${REF}208`
        }
    },
    "attributes": {}
};
const anonGraphOpRefs = [`${REF}207`, `${REF}208`];

const anonGraphData1Shell = {
    "type": "graphdata",
    "str": "GraphData",
    "name": null,
    "data": null,
};
const anonGraphData1Data = {
    "viewer": {
        "creatorop": null,
    },
    "attributes": {}
};
const anonGraphData1Refs = [];

const anonGraphData2Shell = {
    "type": "graphdata",
    "str": "GraphData",
    "name": null,
    "data": null,
};
const anonGraphData2Data = {
    "viewer": {
        "creatorop": null,
    },
    "attributes": {}
};
const anonGraphData2Refs = [];

// =====================================================================================================================
// Mock VisualDebugger python program.
// =====================================================================================================================

// Note: Level-n examples have symbol IDs starting with n.
let allShells = {};
let allData = {};
let allRefs = {};

// Generation 1
// ------------
// When the client first connects, the debugger sends level-0 shell schemas. These are named symbols in the global
// namespace.

allShells[`${REF}001`] = namedInt;
allShells[`${REF}002`] = namedFloat;
allShells[`${REF}003`] = namedBool;
allShells[`${REF}004`] = namedString;
allShells[`${REF}005`] = namedNone;
allShells[`${REF}006`] = namedListShell;
allShells[`${REF}007`] = namedGraphDataShell;

let initialShells = JSON.parse(JSON.stringify(allShells));  // Deep clone so calling `loadSymbol()` does not change it

// Generation 2
// ------------
// When the client attempts to expand a particular level-0 shell schema, an API call will request the
// the data to fill that shell (level-0 data) AND any referenced level-1 shell schemas.

allData[`${REF}006`] = namedListData;
allRefs[`${REF}006`] = namedListRefs;
allData[`${REF}007`] = namedGraphDataData;
allRefs[`${REF}007`] = namedGraphDataRefs;
// ... more non-termal data

allShells[`${REF}106`] = anonListShell;
allShells[`${REF}107`] = anonGraphOpShell;
// ... more shells


// Generation 3 (and beyond)
// -------------------------
// Similar to Generation 2. Most examples terminate after 1 level of expansion, except for the list example which
// terminates after 2 levels in order to test recursive nesting.

allData[`${REF}106`] = anonListData;
allRefs[`${REF}106`] = anonListRefs;
allData[`${REF}107`] = anonGraphOpData;
allRefs[`${REF}107`] = anonGraphOpRefs;
// ... more terminal data

// special case: additional level for list
allShells[`${REF}206`] = anonListShell2;
allData[`${REF}206`] = anonListData2;
allRefs[`${REF}206`] = anonListRefs2;

allShells[`${REF}207`] = anonGraphData1Shell;
allData[`${REF}207`] = anonGraphData1Data;
allRefs[`${REF}207`] = anonGraphData1Refs;

allShells[`${REF}208`] = anonGraphData2Shell;
allData[`${REF}208`] = anonGraphData2Data;
allRefs[`${REF}208`] = anonGraphData2Refs;
// API call mocks
// --------------
// Should return data in same format as future API call functions.

/**
 * Returns the initial global namespace shell schemas.
 */
function loadGlobals() {
    return initialShells;  // TODO: Need to JSON.stringify()?
}

/**
 * Returns a dict of symbol schema (filled or shells) to add to the symbol table. Existing symbols, in particular
 * the shell with `symbolID`, will be replaced.
 * @param symbolID
 */
function loadSymbol(symbolID) {
    let newData = allData[symbolID];
    let newShells = {};
    for(const ref of allRefs[symbolID]) {
        newShells[ref] = allShells[ref];
    }
    return {data: newData, shells: newShells};
}

export {
    loadGlobals,
    loadSymbol,
    REF,
};
