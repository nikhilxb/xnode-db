import React, { Component } from 'react';
import { withStyles } from 'material-ui/styles';
import ELK from 'elkjs';
import GraphEdge from './GraphEdge.js';
import { bindActionCreators } from 'redux';
import {ensureGraphLoadedActionThunk} from "../../../actions/symboltable";
import {setInViewerPayloadAction} from '../../../actions/canvas';
import {makeGetGraphFromHead, layoutGraph, portIdToNodeId} from "./layout";
import {connect} from "react-redux";
import GraphDataViewer from './GraphDataViewer.js';
import GraphOpViewer from './GraphOpViewer.js';
import GraphContainerViewer from './GraphContainerViewer.js';
import {createSelector} from "reselect";

const styles = theme => ({

});

/**
 * This class builds and contains all the components of a computation graph.
 * Payload state slice:
 * {
 *      graphState: {
 *          symbolId: {
 *              expanded: false,
 *          }
 *      },
 *      graph: [{
 *          id: 'root',
 *          children: [{...}, {...}],
 *          edges: [{...}, {...}],
 *      }, {...}]
 *      stateChanged: false,
 * }
 */
class GraphViewer extends Component {
    componentDidMount() {
        let { ensureGraphLoaded, symbolId, viewerId } = this.props;
        ensureGraphLoaded(symbolId, viewerId);
    }

    /**
     * If the viewer is receiving new nodes or edges (generated by `makeGetGraphFromHead()`), then it lays out the graph
     * in a promise and updates the Redux store when complete.
     * @param nextProps
     */
    componentWillReceiveProps(nextProps) {
        let { graphSkeleton, viewerId, setInPayload } = this.props;
        let { graphSkeleton: nextGraphSkeleton } = nextProps;
        let { stateChanged } = nextProps.payload;
        if (nextGraphSkeleton && (!graphSkeleton || stateChanged)) {
            setInPayload(viewerId, ['stateChanged'], false);
            let elk = new ELK();
            layoutGraph(elk, nextGraphSkeleton, viewerId, setInPayload);
        }
    }

    /**
     * Recursively adds new `GraphEdge` components to the `components` array.
     * @param elkNode: An ELK node object which contains at least `x` and `y` fields, as well as an array of edge
     *                 objects. Each edge has a list of source port ids (of length exactly one) and a list of target
     *                 port ids (also of length exactly one). Note that node ids (different from port ids) are of the
     *                 form
     *                      [0-9]?{symbolId}
     *                 where the leading digit is only added if the same symbol appears in multiple nodes (like if it
     *                 is a leaf in multiple temporal containers). A port id is of the form
      *                     {nodeId}_{portNumber}
      *                The edge also contains an array `sections`, also of length exactly one (ELK supports hyperedges,
     *                 hence why everything is a list). This section object has a start point and an end point, as well
     *                 as an array of bend points, indicating points the final edge should pass through.
     * @param components: The list to which new edge components should be added.
     * @param offset: The position offset at which new edges should be rendered. Edge positions are relative, so we must
     *                maintain an offset value to position them globally. Edges aren't just offset from their parent
     *                node, however. An edge is stored in the node which is the first common ancestor of the edge's
     *                source and its target. For edges that connect a container to one of its children, this means that
     *                only the container is in `elkNode`'s children, while the target is stored in the container's node
     *                object. In this case, the edge is offset not by `elkNode`'s position, but by the position of the
     *                container node.
     */
    buildEdgeComponents(elkNode, components=[], offset={x: 0, y: 0}) {
        for (let i = 0; i < elkNode.edges.length; i++) {
            let points = [];
            // If the edge connects a container to its child, offset it by the position of the container
            let extraOffset = {x: 0, y: 0};
            // Our manually-created temporal edges don't have source and target nodes, so skip this step
            if (elkNode.edges[i].sources) {
                let sourceNodeId = portIdToNodeId(elkNode.edges[i].sources[0]);
                let targetNodeId = portIdToNodeId(elkNode.edges[i].targets[0]);
                let sourceNodeIndex = elkNode.children.map(n => n.id).indexOf(sourceNodeId);
                let targetNodeIndex = elkNode.children.map(n => n.id).indexOf(targetNodeId);
                if (targetNodeIndex === -1) {
                    extraOffset = {x: elkNode.children[sourceNodeIndex].x, y: elkNode.children[sourceNodeIndex].y};
                }
                else if (sourceNodeIndex === -1) {
                    extraOffset = {x: elkNode.children[targetNodeIndex].x, y: elkNode.children[targetNodeIndex].y};
                }
            }
            let { startPoint, endPoint } = elkNode.edges[i].sections[0];
            points.push({x: startPoint.x + offset.x + extraOffset.x, y: startPoint.y + offset.y + extraOffset.y});
            if (elkNode.edges[i].sections[0].bendPoints) {
                elkNode.edges[i].sections[0].bendPoints.forEach(({x, y}) => {
                    points.push({x: x + offset.x + extraOffset.x, y: y + offset.y + extraOffset.y});
                });
            }
            points.push({x: endPoint.x + offset.x + extraOffset.x, y: endPoint.y + offset.y + extraOffset.y});
            components.push(<GraphEdge points={points}/>);
        }
        for (let i = 0; i< elkNode.children.length; i ++) {
            let {x, y} = elkNode.children[i];
            this.buildEdgeComponents(elkNode.children[i], components, {x: offset.x + x, y: offset.y + y});
        }
        return components;
    }

    /**
     * Recursively builds node components and adds them to `components`.
     * @param elkNode: A node in the ELK graph, containing a (possibly empty) list of child nodes as well as `width`,
     *                 `height`, `x`, `y`, and `viewerObj` fields. `viewerObj` contains the properties needed to render
     *                 the node (type, name, str, symbolId, and data.viewer).
     * @param components: The array to which node components should be added.
     * @param offset: The pixel offset at which the component should be rendered. ELK uses relative positioning, meaning
     *                that a node's global position should be equal to its parent's global position, plus the node's `x`
     *                and `y` values.
     */
    buildNodeComponents(elkNode, components=[], offset={x: 0, y: 0}) {
        for (let i = 0; i < elkNode.children.length; i++) {
            let {viewerObj, width, height, x, y} = elkNode.children[i];
            let { type, symbolId } = viewerObj;
            if (type === 'graphdata') {
                components.push(<div style={{position: "absolute", left: x + offset.x, top: y + offset.y, width, height}}><GraphDataViewer key={symbolId} {...viewerObj} /></div>);
            }
            if (type === 'graphop') {
                components.push(<div style={{position: "absolute", left: x + offset.x, top: y + offset.y, width, height}}><GraphOpViewer key={symbolId} {...viewerObj} /></div>);
            }
            if (type === 'graphcontainer') {
                components.push(<div style={{position: "absolute", left: x + offset.x, top: y + offset.y, width, height}}><GraphContainerViewer key={symbolId} {...viewerObj} toggleExpanded={(nodeId) => this.toggleExpanded(nodeId)}/></div>);
            }
            this.buildNodeComponents(elkNode.children[i], components, {x: x + offset.x, y: y + offset.y});
        }
        return components;
    }

    toggleExpanded(symbolId) {
        let { setInPayload, viewerId } = this.props;
        let { expanded } = this.props.payload.graphState[symbolId];
        setInPayload(viewerId, ['graphState', symbolId, 'expanded'], !expanded);
        setInPayload(viewerId, ['stateChanged'], true);
    }

    /**
     * Renders all of the graph's op and data components, laid out by ELK.
     */
    render() {
        let { graph } = this.props.payload;
        if (!graph) {
            // TODO loading bar
            return <div />;
        }
        let nodeComponents = this.buildNodeComponents(graph);
        let edgeComponents = this.buildEdgeComponents(graph);

        //let nodeComponents = graph.map(({ children }) => this.buildNodeComponents(children));
       // let edgeComponents = graph.map(subgraph => this.buildEdgeComponents(subgraph));
       //  let subgraphs = nodeComponents.map((nodes, i) => {
       //      return <div style={{position: "absolute", left: i * 100, top: 0}}>{nodes.concat(edgeComponents[i])}</div>;
       //  });


        return (
            <div style={{position: "relative"}}>
                {nodeComponents}
                {edgeComponents}
            </div>
        );
    }
}

// Inject styles and data into component
function makeMapStateToProps() {
    const getGraphFromHead = makeGetGraphFromHead();
    return (state, props) => {
        return {
            graphSkeleton: getGraphFromHead(state, props),
        }
    }
}
function mapDispatchToProps(dispatch) {
    return bindActionCreators({
        ensureGraphLoaded: ensureGraphLoadedActionThunk,
        setInPayload: setInViewerPayloadAction,
    }, dispatch);
}

export default connect(makeMapStateToProps, mapDispatchToProps)(withStyles(styles)(GraphViewer));
