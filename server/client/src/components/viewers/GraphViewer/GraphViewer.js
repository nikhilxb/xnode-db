import React, { Component } from 'react';
import { withStyles } from 'material-ui/styles';
import ELK from 'elkjs';
import GraphEdge from './GraphEdge.js';
import { bindActionCreators } from 'redux';
import {ensureGraphLoadedActionThunk} from "../../../actions/symboltable";
import {setInViewerPayloadAction} from '../../../actions/canvas';
import {makeGetGraphFromHead} from "./layout";
import {connect} from "react-redux";
import GraphDataViewer from './GraphDataViewer.js';
import GraphOpViewer from './GraphOpViewer.js';
import GraphContainerViewer from './GraphContainerViewer.js';
import {createSelector} from "reselect";

const styles = theme => ({

});

/**
 * This class builds and contains all the components of a computation graph.
 * Payload state slice:
 * {
 *      graphState: {
 *          symbolId: {
 *              expanded: false,
 *          }
 *      },
 *      graph: {
 *          id: 'root',
 *          children: [{...}, {...}],
 *          edges: [{...}, {...}],
 *      }
 *      stateChanged: false,
 * }
 */
class GraphViewer extends Component {
    componentDidMount() {
        let { ensureGraphLoaded, symbolId, viewerId } = this.props;
        ensureGraphLoaded(symbolId, viewerId);
    }

    /**
     * If the viewer is receiving new nodes or edges (generated by `makeGetGraphFromHead()`), then it lays out the graph
     * in a promise and updates the Redux store when complete.
     * @param nextProps
     */
    componentWillReceiveProps(nextProps) {
        let { graphSkeleton, viewerId, setInPayload } = this.props;
        let { graphSkeleton: nextGraphSkeleton} = nextProps;
        let { stateChanged } = nextProps.payload;
        if (nextGraphSkeleton && (!graphSkeleton || stateChanged)) {
            setInPayload(viewerId, ['stateChanged'], false);
            let elk = new ELK();
            elk.layout(nextGraphSkeleton)
                .then(laidOutGraph => {
                    setInPayload(viewerId, ['graph'], laidOutGraph);
                })
                .catch(console.error);
        }
    }

    buildEdgeComponents(elkNode, components=[], offset={x: 0, y: 0}) {
        for (let i = 0; i < elkNode.edges.length; i++) {
            let points = [];
            let extraOffset = {x: 0, y: 0};
            // If `toPortId()` or `fromPortId()` changes, this may also need to change
            let sourceNode = elkNode.edges[i].sources[0].split('_')[0];
            let targetNode = elkNode.edges[i].targets[0].split('_')[0];
            let sourceNodeIndex = elkNode.children.map(n => n.id).indexOf(sourceNode);
            let targetNodeIndex = elkNode.children.map(n => n.id).indexOf(targetNode);
            if(targetNodeIndex === -1) {
                extraOffset = {x: elkNode.children[sourceNodeIndex].x, y: elkNode.children[sourceNodeIndex].y};
            }
            else if (sourceNodeIndex === -1) {
                extraOffset = {x: elkNode.children[targetNodeIndex].x, y: elkNode.children[targetNodeIndex].y};
            }
            let { startPoint, endPoint } = elkNode.edges[i].sections[0];
            points.push({x: startPoint.x + offset.x + extraOffset.x, y: startPoint.y + offset.y + extraOffset.y});
            if (elkNode.edges[i].sections[0].bendPoints) {
                elkNode.edges[i].sections[0].bendPoints.forEach(({x, y}) => {
                    points.push({x: x + offset.x + extraOffset.x, y: y + offset.y + extraOffset.y});
                });
            }
            points.push({x: endPoint.x + offset.x + extraOffset.x, y: endPoint.y + offset.y + extraOffset.y});
            components.push(<GraphEdge points={points}/>);
        }
        for (let i = 0; i< elkNode.children.length; i ++) {
            let {x, y} = elkNode.children[i];
            this.buildEdgeComponents(elkNode.children[i], components, {x: offset.x + x, y: offset.y + y});
        }
        return components;
    }

    buildNodeComponents(children, components=[], offset={x: 0, y: 0}) {
        for (let i = 0; i < children.length; i++) {
            let {viewerObj, width, height, x, y} = children[i];
            let { type, symbolId } = viewerObj;
            if (type === 'graphdata') {
                components.push(<div style={{position: "absolute", left: x + offset.x, top: y + offset.y, width, height}}><GraphDataViewer key={symbolId} {...viewerObj} /></div>);
            }
            if (type === 'graphop') {
                components.push(<div style={{position: "absolute", left: x + offset.x, top: y + offset.y, width, height}}><GraphOpViewer key={symbolId} {...viewerObj} /></div>);
            }
            if (type === 'graphcontainer') {
                components.push(<div style={{position: "absolute", left: x + offset.x, top: y + offset.y, width, height}}><GraphContainerViewer key={symbolId} {...viewerObj} toggleExpanded={(nodeId) => this.toggleExpanded(nodeId)}/></div>);
            }
            this.buildNodeComponents(children[i].children, components, {x: x + offset.x, y: y + offset.y});
        }
        return components;
    }

    toggleExpanded(symbolId) {
        let { setInPayload, viewerId } = this.props;
        let { expanded } = this.props.payload.graphState[symbolId];
        setInPayload(viewerId, ['graphState', symbolId, 'expanded'], !expanded);
        setInPayload(viewerId, ['stateChanged'], true);
    }

    /**
     * Renders all of the graph's op and data components, laid out by ELK.
     */
    render() {
        let { graph } = this.props.payload;
        if (!graph) {
            // TODO loading bar
            return <div />;
        }
        let nodeComponents = this.buildNodeComponents(graph.children);
        let edgeComponents = this.buildEdgeComponents(graph);
        return (
            <div style={{position: "relative", width: graph.width, height: graph.height}}>
                {nodeComponents}
                {edgeComponents}
            </div>
        );
    }
}

// Inject styles and data into component
function makeMapStateToProps() {
    const getGraphFromHead = makeGetGraphFromHead();
    return (state, props) => {
        return {
            graphSkeleton: getGraphFromHead(state, props),
        }
    }
}
function mapDispatchToProps(dispatch) {
    return bindActionCreators({
        ensureGraphLoaded: ensureGraphLoadedActionThunk,
        setInPayload: setInViewerPayloadAction,
    }, dispatch);
}

export default connect(makeMapStateToProps, mapDispatchToProps)(withStyles(styles)(GraphViewer));
