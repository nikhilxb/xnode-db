import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { withStyles } from 'material-ui/styles';
import { createSelector } from "reselect";
import ELK from 'elkjs';

import { ensureGraphLoadedActionThunk } from "../../../actions/symboltable";
import { setInViewerPayloadAction } from '../../../actions/canvas';
import { makeGetElkGraphFromHead, layoutGraph } from "./layout";

import GraphOpNode from './GraphOpNode';
import GraphDataEdge from './GraphDataEdge';
import GraphDataNode from './GraphDataNode';
import GraphContainerNode from './GraphContainerNode';
import GraphDataViewer from './GraphDataViewer';

import Tooltip from '../../Tooltip';
import Typography from 'material-ui/Typography';
import { CircularProgress } from 'material-ui/Progress';
import List, { ListItem, ListItemText } from 'material-ui/List';
import ColorGrey from 'material-ui/colors/grey';
import ColorBlue from "material-ui/colors/blue";


/**
 * This smart component builds and contains all the components of a computation graph.
 * The `payload` prop:
 * {
 *      graphState: {
 *          symbolId: {
 *              expanded: false,
 *          },
 *          ...
 *      },
 *      graph: {
 *          id: 'root',
 *          children: [{...}, {...}],
 *          edges: [{...}, {...}],
 *      },
 *      stateChanged: false,
 *      graphLoaded: false,
 * }
 */
class GraphViewer extends Component {

    /** Prop expected types object. */
    static propTypes = {
        classes:            PropTypes.object.isRequired,
        graphSkeleton:      PropTypes.object,
        ensureGraphLoaded:  PropTypes.func.isRequired,
        setInPayload:       PropTypes.func.isRequired,
    };

    constructor(props) {
        super(props);
        this.state = {
            selectedIds: new Set([]),
            hoverIds: new Set([]),
            isInspectorExpanded: true,
        };
        this.setSelectedId = this.setSelectedId.bind(this);
        this.setHoverId = this.setHoverId.bind(this);
    }

    componentDidMount() {
        let { ensureGraphLoaded, symbolId, viewerId } = this.props;
        ensureGraphLoaded(symbolId, viewerId);
    }

    /**
     * If the viewer is receiving new nodes or edges (generated by `makeGetElkGraphFromHead()`), then it lays out the graph
     * in a promise and updates the Redux store when complete.
     *
     * @param nextProps
     */
    componentWillReceiveProps(nextProps) {
        let { graphSkeleton, viewerId, setInPayload } = this.props;
        let { graphSkeleton: nextGraphSkeleton } = nextProps;
        let { stateChanged } = nextProps.payload;
        if (nextGraphSkeleton && (!graphSkeleton || stateChanged)) {
            setInPayload(viewerId, ['stateChanged'], false);
            let elk = new ELK();
            layoutGraph(elk, nextGraphSkeleton, viewerId, setInPayload);
            this.setState({
                selectedIds: new Set(),
                hoverIds: new Set(),
            });
        }
    }

    setSelectedId(id) {
        this.setState(prev => ({
            selectedIds: id ? new Set([id]) : new Set([id]),
        }));
    }

    setHoverId(id) {
        this.setState(prev => ({
            hoverIds: id ? prev.hoverIds.add(id) : new Set(),
        }));
    }

    toggleInspectorExpanded() {
        this.setState(prev => ({
            isInspectorExpanded: !prev.isInspectorExpanded,
        }));
    }

    /**
     * Recursively adds new `GraphDataEdge` components to the `components` array.
     *
     * @param elkNode
     *     An ELK node object which contains at least `x` and `y` fields, as well as an array of edge objects. Each
     *     edge has a list of source port ids (of length exactly one) and a list of target port ids (also of length
     *     exactly one). Note that node ids (different from port ids) are of the form
     *         [0-9]?{symbolId}
     *     where the leading digit is only added if the same symbol appears in multiple nodes (like if it is a leaf
     *     in multiple temporal containers). A port id is of the form
     *         {nodeId}_{portNumber}
     *     The edge also contains an array `sections`, also of length exactly one (ELK supports hyperedges, hence
     *     why everything is a list). This section object has a start point and an end point, as well as an array
     *     of bend points, indicating points the final edge should pass through.
     * @param components
     *     The list to which new edge components should be added.
     * @param offset
     *     The position offset at which new edges should be rendered. Edge positions are relative, so we must
     *     maintain an offset value to position them globally. Edges aren't just offset from their parent node,
     *     however. An edge is stored in the node which is the first common ancestor of the edge's source and its
     *     target. For edges that connect a container to one of its children, this means that only the container is
     *     in `elkNode`'s children, while the target is stored in the container's node  object. In this case, the
     *     edge is offset not by `elkNode`'s position, but by the position of the container node.
     */
    buildEdgeComponents(edges) {
        return edges.map(edge => {
            const { key, points, zOrder, isTemporal, viewerObj, sourceSymbolId, targetSymbolId, argName } = edge;
            const tooltipObj = {
                ...viewerObj,
            };
            const layoutObj = {
                points,
                zOrder,
                isTemporal,
                sourceSymbolId,
                targetSymbolId,
                argName,
                setSelected:    (isSelected = true) => this.setSelectedId(isSelected ? viewerObj.symbolId : null),
                setHover:       (isHovered = true) => this.setHoverId(isHovered ? viewerObj.symbolId : null),
                selectedIds:    this.state.selectedIds,
                hoverIds:       this.state.hoverIds,
            };
            return ({
                component: <GraphDataEdge key={key} edgeId={key} {...viewerObj} {...layoutObj} />,
                zOrder,
            });
        });
    }

    /**
     * Recursively builds node components and adds them to `components`.
     *
     * @param elkNode
     *     A node in the ELK graph, containing a (possibly empty) list of child nodes as well as `width`, `height`,
     *     `x`, `y`, and `viewerObj` fields. `viewerObj` contains the properties needed to render the node (type,
     *     name, str, symbolId, and data.viewer).
     * @param components
     *     The array to which node components should be added.
     * @param offset
     *     The pixel offset at which the component should be rendered. ELK uses relative positioning, meaning that a
     *     node's global position should be equal to its parent's global position, plus the node's `x` and `y` values.
     */
    buildNodeComponents(nodes) {
        return nodes.map(node => {
            const { type, key, viewerObj, x, y, width, height, zOrder, isTemporal, isExpanded } = node;
            const layoutProps = {
                width,
                height,
                x,
                y,
                isTemporal,
                isExpanded,
            };
            const interactionProps = {
                setSelected:    (isSelected = true) => this.setSelectedId(isSelected ? viewerObj.symbolId : null),
                setHover:       (isHovered = true) => this.setHoverId(isHovered ? viewerObj.symbolId : null),
                selectedIds:    this.state.selectedIds,
                hoverIds:       this.state.hoverIds,
            };

            switch(type) {
                case 'graphdata':
                    return ({
                        component: <GraphDataNode key={key} {...viewerObj} {...layoutProps} {...interactionProps} />,
                        zOrder,
                    });

                case 'graphop':
                    return ({
                        component: <GraphOpNode key={key} {...viewerObj} {...layoutProps} {...interactionProps}/>,
                        zOrder,
                    });

                case 'graphcontainer':
                    return ({
                        component: <GraphContainerNode key={key} {...viewerObj} {...layoutProps} {...interactionProps}
                                                       toggleExpanded={() => this.toggleExpanded(viewerObj.symbolId)} />,
                        zOrder,
                    });
            }
        });
    }

    argArrToComponents(classes, argArr) {
        let arr = [];
        const [ argName, argVal ] = argArr;
        if (Array.isArray(argVal)) {
            argVal.forEach((arg, i) => {
                arr.push(<ListItem button className={classes.argListItem}><span className={classes.monospace}>{`${argName}[${i}]`}</span></ListItem> );
            });

        }
        else {
            arr.push(<ListItem button className={classes.argListItem}><span className={classes.monospace}>{`${argName}`}</span></ListItem> );
        }
        return arr;
    }

    // TODO on button hover, set hovered symbol id to that argument
    buildInspectorComponents(classes, inspectorObj) {
        let arr = [];
        if (inspectorObj) {
            const { name, type, payload } = inspectorObj;
            arr.push(
                <Typography className={classes.label} variant="caption">Type</Typography>,
                <span>{type ? type : <br/>}</span>
            );
            if (inspectorObj.type === 'graphop') {
                const { args, kwargs } = payload;
                if (args.length > 0) {
                    arr.push( <Typography className={classes.label} variant="caption">Positional Args</Typography> );
                    let argListItems = [];
                    args.forEach(argArr => {
                        argListItems = argListItems.concat(this.argArrToComponents(classes, argArr));
                    });
                    arr.push(<List className={classes.argList}>{argListItems}</List>);
                }

                if (kwargs.length > 0) {
                    arr.push( <Typography className={classes.label} variant="caption">Keyword Args</Typography> );
                    let kwargListItems = [];
                    kwargs.forEach(argArr => {
                        kwargListItems = kwargListItems.concat(this.argArrToComponents(classes, argArr));
                    });
                    arr.push(<List className={classes.argList}>{kwargListItems}</List>);
                }
            }
        }
        return arr;
    };

    toggleExpanded(symbolId) {
        let { setInPayload, viewerId } = this.props;
        let { expanded } = this.props.payload.graphState[symbolId];
        setInPayload(viewerId, ['graphState', symbolId, 'expanded'], !expanded);
        setInPayload(viewerId, ['stateChanged'], true);
    }

    /**
     * Renders all of the graph's op and data components, laid out by ELK. Additionally, displays an inspector fixed to
     * the bottom of the frame that displays the hover/selected item's info.
     */
    render() {
        const { classes, payload } = this.props;
        const { graph } = payload;
        if (!graph) {
            return (
                <div className={classes.container}>
                    <div className={classes.progress}>
                        <CircularProgress />
                    </div>
                </div>
            );
        }

        let graphComponents = this.buildNodeComponents(graph.nodes).concat(this.buildEdgeComponents(graph.edges));
        graphComponents = graphComponents.asMutable().sort(({zOrder: z1}, {zOrder: z2}) => z1 - z2).map(({component}) => component);

        let inspectorComponents = this.buildInspectorComponents(classes, this.state.hoverObj || this.state.selectedObj);

        let buildArrowheadMarker = (id, color) => (
            <marker id={id} viewBox="-5 -3 5 6" refX="0" refY="0"
                    markerUnits="strokeWidth" markerWidth="4" markerHeight="3" orient="auto">
                <path d="M 0 0 l 0 1 a 32 32 0 0 0 -5 2 l 1.5 -3 l -1.5 -3 a 32 32 0 0 0 5 2 l 0 1 z" fill={color} />
            </marker>
        );

        return (
            <div className={classes.container}>
                <div className={classes.graph}>
                    <svg width={graph.width} height={graph.height}>
                        <defs>
                            {buildArrowheadMarker("arrowheadGrey", ColorGrey[600])}
                            {buildArrowheadMarker("arrowheadBlue", ColorBlue[600])}
                        </defs>
                        <rect x={0} y={0} width={graph.width} height={graph.height} fill="transparent"
                              onClick={() => this.setSelectedId(null)}/>
                        {graphComponents}
                    </svg>
                </div>
                <div className={classes.inspector}>
                    {inspectorComponents}
                </div>
            </div>
        );
    }
}

// To inject styles into component
// -------------------------------

/** CSS-in-JS styling object. */
const styles = theme => ({
    container: {
        flex: 1,  // expand to fill frame vertical

        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'center',  // along main axis (horizontal)
        alignItems: 'stretch',  // along cross axis (vertical)
        overflow: 'hidden',
    },
    progress: {
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
    },
    graph: {
        flex: 'auto',
        overflow: 'auto',
        textAlign: 'left', // so SVG doesn't move
    },
    inspector: {
        flex: 'initial',
        minWidth: 150,
        overflow: 'auto',

        boxSizing: 'border-box',
        padding: '4px 12px',
        backgroundColor: ColorGrey[50],
        borderLeftWidth: 1,
        borderLeftStyle: 'solid',
        borderLeftColor: ColorGrey[200],
        fontSize: '9pt',
        textAlign: 'left',

        display: 'flex',
        flexDirection: 'column',
        flexWrap: 'wrap',
        alignItems: 'flex-start',
    },
    label: {
        paddingTop: 8,
    },
    monospace: {
        fontFamily: theme.typography.monospace.fontFamily,
        textTransform: 'lowercase',
    },
    argList: {
        width: '100%',
        height: 'auto',
        overflowY: 'auto',
        overflowX: 'hidden',


        paddingTop: 0,
        paddingBottom: 0,
    },
    argListItem: {
        paddingTop: 0,
        paddingBottom: 0,
    },
});

// To inject application state into component
// ------------------------------------------

/** Connects application state objects to component props. */
function makeMapStateToProps() {
    const getGraphFromHead = makeGetElkGraphFromHead();
    return (state, props) => {
        return {
            graphSkeleton: getGraphFromHead(state, props),
            symbolTable: state.symboltable,  // TODO don't hold on to the whole symbol table -- we're only using it for arg strs!
        }
    }
}

/** Connects bound action creator functions to component props. */
function mapDispatchToProps(dispatch) {
    return bindActionCreators({
        ensureGraphLoaded: ensureGraphLoadedActionThunk,
        setInPayload: setInViewerPayloadAction,
    }, dispatch);
}

export default connect(makeMapStateToProps, mapDispatchToProps)(withStyles(styles)(GraphViewer));